<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Chess</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        #game-container {
            margin: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #board {
            width: 400px;
            height: 400px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 2px solid #333;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .square.white {
            background-color: #f0d9b5;
        }

        .square.black {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fc97f;
        }

        .square.valid-move {
            background-color: #7fc97f80;
        }

        .piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        #status {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
        }

        #opponent-info {
            margin-bottom: 20px;
            font-size: 16px;
        }    </style>
</head>
<body>
    <div id="game-container">
        <div id="opponent-info">Click Start to begin the game</div>
        <div id="board"></div>
        <div id="status"></div>
        <div id="controls">
            <button id="startButton">Start Game</button>
        </div>
    </div>

    <script src="https://pulgram.com/js/pulgram-bridge.js"></script>
    <script>
        class ChessGame {            
            constructor() {
                this.board = document.getElementById('board');
                this.status = document.getElementById('status');
                this.opponentInfo = document.getElementById('opponent-info');
                this.selectedPiece = null;
                this.validMoves = [];
                this.isWhite = true;
                this.gameStarted = false;
                this.gameState = this.createInitialGameState();
                this.gameStatus = 'active'; // active, check, checkmate, stalemate

                this.initializeBoard();
                this.setupMessageListener();
                this.setupStartButton();
            }

            initializeBoard() {
                // Clear the board
                this.board.innerHTML = '';
                this.selectedPiece = null;
                this.validMoves = [];

                // Create squares and pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        
                        // Add piece if there is one
                        const piece = this.gameState.board[row][col];
                        if (piece) {
                            const pieceDiv = document.createElement('div');
                            pieceDiv.className = 'piece';
                            const [color, type] = piece.split('');
                            const colorName = color === 'w' ? 'white' : 'black';
                            const pieceName = {
                                'P': 'pawn',
                                'R': 'rook',
                                'N': 'knight',
                                'B': 'bishop',
                                'Q': 'queen',
                                'K': 'king'
                            }[type];
                            pieceDiv.style.backgroundImage = `url('resources/pieces-basic-png/${colorName}-${pieceName}.png')`;
                            square.appendChild(pieceDiv);
                        }                        // Add click handler
                        square.addEventListener('click', () => {
                            const isMyTurn = (this.gameState.currentTurn === 'w' && this.isWhite) ||
                                           (this.gameState.currentTurn === 'b' && !this.isWhite);
                            
                            if (!this.gameStarted || !isMyTurn || this.gameStatus === 'checkmate' || this.gameStatus === 'stalemate') {
                                return;
                            }

                            // Get the current piece at this position
                            const currentPiece = this.gameState.board[row][col];

                            if (currentPiece && currentPiece[0] === this.gameState.currentTurn) {
                                // Select piece
                                this.board.querySelectorAll('.square').forEach(s => s.classList.remove('selected', 'valid-move'));
                                square.classList.add('selected');
                                this.selectedPiece = { row, col };
                                this.validMoves = this.calculateValidMoves(row, col);
                                
                                // Highlight valid moves
                                this.validMoves.forEach(move => {
                                    const targetSquare = this.board.children[move.row * 8 + move.col];
                                    targetSquare.classList.add('valid-move');
                                });
                            } else if (this.selectedPiece && this.isValidMove(row, col)) {
                                // Make move
                                this.makeMove(row, col);
                            }
                        });

                        this.board.appendChild(square);
                    }
                }
            }

            setupStartButton() {
                const startButton = document.getElementById('startButton');
                startButton.addEventListener('click', () => {
                    if (!this.gameStarted) {
                        this.sendInvitation();
                    }
                });
            }

            createInitialGameState() {
                return {
                    board: [
                        ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
                        ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
                        ['', '', '', '', '', '', '', ''],
                        ['', '', '', '', '', '', '', ''],
                        ['', '', '', '', '', '', '', ''],
                        ['', '', '', '', '', '', '', ''],
                        ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
                        ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
                    ],
                    currentTurn: 'w'
                };
            }

            isKingInCheck(board, color) {
                // Find king's position
                let kingRow = -1, kingCol = -1;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece === `${color}K`) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }

                // Check if any opponent piece can capture the king
                const opponentColor = color === 'w' ? 'b' : 'w';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece[0] === opponentColor) {
                            const moves = this.calculateValidMoves(row, col, board);
                            if (moves.some(move => move.row === kingRow && move.col === kingCol)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            isCheckmate(color) {
                // If not in check, it's not checkmate
                if (!this.isKingInCheck(this.gameState.board, color)) {
                    return false;
                }

                // Try every possible move for all pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece[0] === color) {
                            const moves = this.calculateValidMoves(row, col);
                            // Try each move to see if it gets out of check
                            for (const move of moves) {
                                const tempBoard = this.cloneBoard(this.gameState.board);
                                tempBoard[move.row][move.col] = piece;
                                tempBoard[row][col] = '';
                                if (!this.isKingInCheck(tempBoard, color)) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            }

            isStalemate(color) {
                // If in check, it's not stalemate
                if (this.isKingInCheck(this.gameState.board, color)) {
                    return false;
                }

                // Check if any legal moves are available
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece[0] === color) {
                            const moves = this.calculateValidMoves(row, col);
                            if (moves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            cloneBoard(board) {
                return board.map(row => [...row]);
            }

            calculateValidMoves(row, col, board = this.gameState.board) {
                const moves = [];
                const piece = board[row][col];
                
                if (!piece) return moves;

                const isWhitePiece = piece[0] === 'w';
                const pieceType = piece[1];

                switch (pieceType) {
                    case 'P': // Pawn
                        const direction = isWhitePiece ? -1 : 1;
                        const startRow = isWhitePiece ? 6 : 1;

                        // Move forward one square
                        if (this.isValidPosition(row + direction, col) && 
                            !this.gameState.board[row + direction][col]) {
                            moves.push({ row: row + direction, col: col });

                            // Move forward two squares from starting position
                            if (row === startRow && !this.gameState.board[row + 2 * direction][col]) {
                                moves.push({ row: row + 2 * direction, col: col });
                            }
                        }

                        // Capture diagonally
                        for (let colOffset of [-1, 1]) {
                            if (this.isValidPosition(row + direction, col + colOffset)) {
                                const targetPiece = this.gameState.board[row + direction][col + colOffset];
                                if (targetPiece && targetPiece[0] !== piece[0]) {
                                    moves.push({ row: row + direction, col: col + colOffset });
                                }
                            }
                        }
                        break;

                    case 'R': // Rook
                        // Check horizontal and vertical moves
                        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                        for (let [dx, dy] of directions) {
                            let newRow = row + dx;
                            let newCol = col + dy;
                            while (this.isValidPosition(newRow, newCol)) {
                                const targetPiece = this.gameState.board[newRow][newCol];
                                if (!targetPiece) {
                                    moves.push({ row: newRow, col: newCol });
                                } else {
                                    if (targetPiece[0] !== piece[0]) {
                                        moves.push({ row: newRow, col: newCol });
                                    }
                                    break;
                                }
                                newRow += dx;
                                newCol += dy;
                            }
                        }
                        break;

                    case 'N': // Knight
                        const knightMoves = [
                            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                            [1, -2], [1, 2], [2, -1], [2, 1]
                        ];
                        for (let [dx, dy] of knightMoves) {
                            const newRow = row + dx;
                            const newCol = col + dy;
                            if (this.isValidPosition(newRow, newCol)) {
                                const targetPiece = this.gameState.board[newRow][newCol];
                                if (!targetPiece || targetPiece[0] !== piece[0]) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                            }
                        }
                        break;

                    case 'B': // Bishop
                        const diagonals = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                        for (let [dx, dy] of diagonals) {
                            let newRow = row + dx;
                            let newCol = col + dy;
                            while (this.isValidPosition(newRow, newCol)) {
                                const targetPiece = this.gameState.board[newRow][newCol];
                                if (!targetPiece) {
                                    moves.push({ row: newRow, col: newCol });
                                } else {
                                    if (targetPiece[0] !== piece[0]) {
                                        moves.push({ row: newRow, col: newCol });
                                    }
                                    break;
                                }
                                newRow += dx;
                                newCol += dy;
                            }
                        }
                        break;

                    case 'Q': // Queen (combination of Rook and Bishop moves)
                        const queenDirections = [
                            [0, 1], [0, -1], [1, 0], [-1, 0],
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ];
                        for (let [dx, dy] of queenDirections) {
                            let newRow = row + dx;
                            let newCol = col + dy;
                            while (this.isValidPosition(newRow, newCol)) {
                                const targetPiece = this.gameState.board[newRow][newCol];
                                if (!targetPiece) {
                                    moves.push({ row: newRow, col: newCol });
                                } else {
                                    if (targetPiece[0] !== piece[0]) {
                                        moves.push({ row: newRow, col: newCol });
                                    }
                                    break;
                                }
                                newRow += dx;
                                newCol += dy;
                            }
                        }
                        break;

                    case 'K': // King
                        const kingMoves = [
                            [-1, -1], [-1, 0], [-1, 1],
                            [0, -1], [0, 1],
                            [1, -1], [1, 0], [1, 1]
                        ];
                        for (let [dx, dy] of kingMoves) {
                            const newRow = row + dx;
                            const newCol = col + dy;
                            if (this.isValidPosition(newRow, newCol)) {
                                const targetPiece = this.gameState.board[newRow][newCol];
                                if (!targetPiece || targetPiece[0] !== piece[0]) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                            }
                        }
                        break;
                }

                // Filter out moves that would put or leave own king in check
                return moves.filter(move => {
                    const tempBoard = this.cloneBoard(board);
                    tempBoard[move.row][move.col] = piece;
                    tempBoard[row][col] = '';
                    return !this.isKingInCheck(tempBoard, piece[0]);
                });
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            isValidMove(toRow, toCol) {
                return this.validMoves.some(move => move.row === toRow && move.col === toCol);
            }            makeMove(toRow, toCol) {
                const fromRow = this.selectedPiece.row;
                const fromCol = this.selectedPiece.col;
                const piece = this.gameState.board[fromRow][fromCol];

                // Update game state
                this.gameState.board[toRow][toCol] = piece;
                this.gameState.board[fromRow][fromCol] = '';
                
                // Switch turns
                this.gameState.currentTurn = this.gameState.currentTurn === 'w' ? 'b' : 'w';

                // Check game status
                const opponentColor = this.gameState.currentTurn;
                if (this.isCheckmate(opponentColor)) {
                    this.gameStatus = 'checkmate';
                } else if (this.isKingInCheck(this.gameState.board, opponentColor)) {
                    this.gameStatus = 'check';
                } else if (this.isStalemate(opponentColor)) {
                    this.gameStatus = 'stalemate';
                } else {
                    this.gameStatus = 'active';
                }

                // Send move to opponent
                if (this.gameStarted) {
                    const moveMessage = {
                        type: 'chess_move',
                        move: {
                            from: { row: fromRow, col: fromCol },
                            to: { row: toRow, col: toCol },
                            piece: piece
                        },
                        gameStatus: this.gameStatus
                    };

                    const message = pulgram.createMessage(
                        JSON.stringify(moveMessage),
                        pulgram.MessageType.TEXT,
                        pulgram.ReceiverType.USER
                    );
                    message.receiverId = "";
                    message.sessionId = "";
                    pulgram.sendMessage(message);
                }

                this.initializeBoard();
                this.updateStatus();
            }

            handleOpponentMove(moveData) {
                const { from, to, piece, gameStatus } = moveData;
                this.gameState.board[from.row][from.col] = '';
                this.gameState.board[to.row][to.col] = piece;
                this.gameState.currentTurn = this.gameState.currentTurn === 'w' ? 'b' : 'w';
                this.gameStatus = gameStatus || 'active';
                this.initializeBoard();
                this.updateStatus();
            }

            updateStatus() {
                const isMyTurn = (this.gameState.currentTurn === 'w' && this.isWhite) ||
                                (this.gameState.currentTurn === 'b' && !this.isWhite);
                
                let statusText = '';
                if (this.gameStatus === 'checkmate') {
                    statusText = `Game Over - ${this.gameState.currentTurn === 'w' ? 'Black' : 'White'} wins by checkmate!`;
                    this.showRematchButton();
                } else if (this.gameStatus === 'stalemate') {
                    statusText = 'Game Over - Draw by stalemate!';
                    this.showRematchButton();
                } else if (this.gameStatus === 'check') {
                    statusText = `${this.gameState.currentTurn === 'w' ? 'White' : 'Black'} is in check! ${isMyTurn ? 'Your turn' : "Opponent's turn"}`;
                } else {
                    statusText = isMyTurn ? 'Your turn' : "Opponent's turn";
                }
                
                this.status.textContent = statusText;
            }

            showRematchButton() {
                const controls = document.getElementById('controls');
                if (!document.getElementById('rematchButton')) {
                    const rematchButton = document.createElement('button');
                    rematchButton.id = 'rematchButton';
                    rematchButton.textContent = 'Rematch';
                    rematchButton.addEventListener('click', () => this.requestRematch());
                    controls.appendChild(rematchButton);
                }
            }

            requestRematch() {
                const rematchMessage = pulgram.createMessage(
                    JSON.stringify({ type: 'chess_rematch_request' }),
                    pulgram.MessageType.TEXT,
                    pulgram.ReceiverType.USER
                );
                pulgram.sendMessage(rematchMessage);
            }

            resetGame() {
                this.gameState = this.createInitialGameState();
                this.gameStatus = 'active';
                this.selectedPiece = null;
                this.validMoves = [];
                this.initializeBoard();
                this.updateStatus();
                
                const rematchButton = document.getElementById('rematchButton');
                if (rematchButton) {
                    rematchButton.remove();
                }
            }

            setupMessageListener() {
                pulgram.setOnMessageReceivedListener(async (message) => {
                    if (message.type === pulgram.MessageType.TEXT) {
                        try {
                            const data = JSON.parse(message.content);
                            if (data.type === 'chess_invitation') {
                                if (!this.gameStarted) {
                                    this.acceptInvitation();
                                }
                            } else if (data.type === 'chess_accept') {
                                if (!this.gameStarted) {
                                    this.startGame(true);
                                }
                            } else if (data.type === 'chess_move') {
                                if (this.gameStarted) {
                                    this.handleOpponentMove(data.move);
                                }
                            } else if (data.type === 'chess_rematch_request') {
                                if (confirm('Opponent wants a rematch. Accept?')) {
                                    const response = pulgram.createMessage(
                                        JSON.stringify({ type: 'chess_rematch_accept' }),
                                        pulgram.MessageType.TEXT
                                    );
                                    pulgram.sendMessage(response);
                                    this.resetGame();
                                    this.startGame(!this.isWhite); // Switch colors for rematch
                                }
                            } else if (data.type === 'chess_rematch_accept') {
                                this.resetGame();
                                this.startGame(!this.isWhite); // Switch colors for rematch
                            }
                        } catch (e) {
                            // Not a game message, ignore
                        }
                    }
                });
            }

            async startGame(isWhite) {
                this.gameStarted = true;
                this.isWhite = isWhite;
                
                // Update UI
                document.getElementById('startButton').style.display = 'none';
                this.opponentInfo.textContent = 'Game in progress';
                this.updateStatus();
            }

            acceptInvitation() {
                // Send acceptance
                const response = pulgram.createMessage(
                    JSON.stringify({ type: 'chess_accept' }),
                    pulgram.MessageType.TEXT
                );
                pulgram.sendMessage(response);
                
                // Start game as black
                this.startGame(false);
            }

            sendInvitation() {
                if (!this.gameStarted) {
                    const invitation = pulgram.createMessage(
                        JSON.stringify({ type: 'chess_invitation' }),
                        pulgram.MessageType.TEXT
                    );
                    console.log('Sending:', JSON.stringify(invitation));
                    pulgram.sendMessage(invitation);
                    this.opponentInfo.textContent = 'Waiting for opponent to accept...';
                }            }
        }

        // Initialize the game when the SDK is ready
        document.addEventListener('pulgramready', () => {
            window.game = new ChessGame();
        });
    </script>
</body>
</html>